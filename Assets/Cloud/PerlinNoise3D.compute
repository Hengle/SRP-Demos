#pragma kernel GenNoise

RWTexture3D<float> OutputTexture;
float3 OutputSize;
float Scale;
int Iteration;
float Seed;
StructuredBuffer<int> perm;

#define PHI (1.61803398874989484820459 * 00000.1)
#define PI (3.14159265358979323846264 * 00000.1)
#define SQ2 (1.41421356237309504880169 * 10000.0)
#define E (2.71828182846)
#define BIAS_X (1.31)
#define BIAS_Y (1.17)
#define BIAS_Z (1.57)

// https://www.shadertoy.com/view/wtsSW4
inline float gold_noise3(float3 pos, float seed)
{
    return frac(tan(distance(pos * (PHI + seed), float3(PHI, PI, E))) * SQ2) * 2 - 1;
}

inline float fade(float t)
{
    return pow(t, 3) * (t * (t * 6 - 15) + 10);
}

inline float smoothLerp(float t, float a, float b)
{
    return a + t * (b - a);
}

inline float3 gridAt(float3 pos)
{
    return float3(
        gold_noise3(pos, Seed * BIAS_X) + 0.00001,
        gold_noise3(pos, Seed + BIAS_Y) + 0.00001,
        gold_noise3(pos, Seed / BIAS_Z) + 0.00001
    );
}

inline float grad(float3 v, float3 offset)
{
    return length(v) <= 0 ? 0 : dot(normalize(v), offset);
}

inline float noise(float3 pos, float3 repeatSize)
{
    pos = pos % repeatSize;
    uint3 p = floor(pos);
    
    p %= 256;
    pos -= floor(pos);
    float u = fade(pos.x);
    float v = fade(pos.y);
    float w = fade(pos.z);

    uint A =  (perm[(p.x    ) % repeatSize.x] + p.y) % repeatSize.y;
    uint B =  (perm[(p.x + 1) % repeatSize.x] + p.y) % repeatSize.y;
    uint AA = (perm[(A      ) % repeatSize.x] + p.z) % repeatSize.z;
    uint BA = (perm[(B      ) % repeatSize.x] + p.z) % repeatSize.z;
    uint AB = (perm[(A + 1  ) % repeatSize.x] + p.z) % repeatSize.z;
    uint BB = (perm[(B + 1  ) % repeatSize.x] + p.z) % repeatSize.z;
    //return grad(gridAt(p + float3(0,0,0)), pos - float3(0,0,0));

    //return perm[AB+1] / 255.0f;

    return smoothLerp(w, smoothLerp(v, smoothLerp(u, grad(gridAt((p + float3(0,0,0)) % repeatSize), pos - float3(0,0,0)), grad(gridAt((p + float3(1,0,0)) % repeatSize), pos - float3(1,0,0))),
                                       smoothLerp(u, grad(gridAt((p + float3(0,1,0)) % repeatSize), pos - float3(0,1,0)), grad(gridAt((p + float3(1,1,0)) % repeatSize), pos - float3(1,1,0)))),
                         smoothLerp(v, smoothLerp(u, grad(gridAt((p + float3(0,0,1)) % repeatSize), pos - float3(0,0,1)), grad(gridAt((p + float3(1,0,1)) % repeatSize), pos - float3(1,0,1))),
                                       smoothLerp(u, grad(gridAt((p + float3(0,1,1)) % repeatSize), pos - float3(0,1,1)), grad(gridAt((p + float3(1,1,1)) % repeatSize), pos - float3(1,1,1)))));
                                       
}

inline float fbm(float3 pos, int iteration, float3 repeatSize)
{
    float value = 0;
    float amplitude = .5f;
    for(int i = 0; i < iteration; i++)
    {
        value += amplitude * noise(pos, repeatSize);
        pos *= 2;
        repeatSize *= 2;
        amplitude *= .5;
    }
    return value;
}

[numthreads(8,8,8)]
void GenNoise (uint3 id : SV_DispatchThreadID)
{
    OutputTexture[id.xyz] = fbm(id.xyz / Scale, Iteration, OutputSize / Scale);
}
